#!/usr/bin/python
"""
A.R.F. (Archive Retrieval Fiend)
--------------------------------------------------------------------
Concept:
    This script exists for two reasons:
        1) Lazy people don't want to type long commands like "tar zxvf" and
	   "unzip" and "unrar", or their respective commandline parameters
        2) Downloading a tarball, extracting it, then deleting it
           is a wasteful and boring process

    This script remedies that situation. Just run "arf (filename or URL)"
    and it'll figure out how to extract it, and put the files in a nicely named
    directory. It works on http, https, and FTP urls.
    
    The directory creation works like this:
       + if the archive contains one directory, extract it as is
       + if the archive contains more than that, make a directory named
	  after the filename with the archive extension removed.

Examples:
    arf http://prdownloads.sourceforge.net/something/mrprogram-1.2.45.6.3.tar.bz2
    arf warez/Awesome.Game.RZR.FLT.DEViANCE/rzrflddev-ag.rar
    arf pile_of_junk.tgz /root

todo:
    + better implementation
        - FileExtractor takes a 'thing' in its __init__ (throwing an exception if it can't handle it), then
          returns an instance that allows the user to '.extract(destination)' the archive.
    + list the contents of the archive 
      - arf l <archive name> will list an archive contents (piped to less)
      - when <archive name> is an url, give the option to extract it afterwards
"""
__version__ = '0.5.2'

import os, sys, re, urllib, time, tempfile
from os.path import join, isfile, isdir, exists, split, splitext

def madProps():
    s = "  arf! (Archive Retriever, Fo'sho') v%s :: by Chris Gahan (chris@ill-logic.com)  " % __version__
    print '=' * len(s)
    print s
    print '=' * len(s)
    print

def howToUseMe():
    print 'This program takes a compressed file from an url or a filename, figures out'
    print 'what type of file it is, then tries to extract it into a directory.'
    print
    exts = []
    for extractor in extractors:
        exts.extend(extractor.exts)
    print 'Supported filetypes:\n    %s' % ', '.join(exts)
    print
    print 'Usage:'
    print '    %s <input file or url> [output directory]' % sys.argv[0]
    print
    print 'The [output directory] is optional. By default, the current directory is used.'
    print
    
def execute(cmd):
    error = os.system(cmd)
    if error != 0:
        raise Exception, "Error! System command returned errorcode %d.\nCommand was: '%s'" % (error, cmd)
        
def prompt(message='(Y/n)? ', choices=['y','n'], default='y'):
    inp = None
    while not (inp in choices) and inp != '':
        inp = raw_input(message).lower()
    
    if inp == '':
        inp = default

    return default
            
def isurl(thing):
    return thing.startswith('http://') or thing.startswith('https://') or thing.startswith('ftp://')

def isoption(arg):
    if arg[0] != '-' or os.path.exists(arg):
        return False
    else:
        return True

def only_dir_in_path(dir):
    entries = os.listdir(dir)
    dirs = []
    for entry in entries:
        fullentry = join(dir,entry)
        if isfile(fullentry):
            return None
        if isdir(fullentry):
            dirs.append(entry)
        if len(dirs) > 1:
            return None

    return dirs[0]

class URLGrabber(urllib.FancyURLopener):
    lastdisplaystring = ''

    def reporthook(self, blockcount, blocksize, filesize):
        """ Print the current transfer statistics """
    
        bytes = blockcount * blocksize
        if bytes > filesize:
            bytes = filesize
    
        percent = (bytes*100.0)/filesize
        now = time.time()
        if now - self.starttime == 0.0:
            now += 0.0001
        speed = (bytes / (now - self.starttime)) / 1024
    
        lastlen = len(self.lastdisplaystring)
        #dmesg('lastline = %d' % lastlen)
        print '\x08' * (lastlen+2),
        nextline = '%0.1f%% complete (%d/%d bytes) - %0.2f k/sec' % (percent, bytes, filesize, speed)
        #dmesg('nextline = %d' % len(nextline))
        if len(nextline) < lastlen:
            nextline += ' '*(lastlen - len(nextline))
    
        #dmesg('newnextline = %d' % len(nextline))
        print nextline,
    
        self.lastdisplaystring = nextline
    
    def retrieve(self, url):
        def reporthookwrapper(blockcount, blocksize, filesize):
            self.reporthook(blockcount, blocksize, filesize)
        
        self.lastdisplaystring = ''
        self.starttime = time.time()
        return urllib.FancyURLopener.retrieve(self, url, reporthook=reporthookwrapper)

class FileExtractor:
    """ Mother class!! """
    
    exts = []
    streamable = False

    def canHandle(self, filename):
        """ Can you handle the file? CAN YOU HANDLE THE FILE?!!? """
        filename = filename.lower()
        for ext in self.exts:
            if filename.endswith(ext):
                return True
        return False

    def dirname_from_archivename(self, archivename):
        lowername = archivename.lower()
        for ext in self.exts:
            if lowername.endswith(ext):
                return archivename.rstrip(ext)
        return None
        
    
    def extract_file(self, filename, destdir='.'):
        raise Exception, "extract_file() not implemented!"
    
    def extract_url(self, url, destdir='.'):
        opener = URLGrabber()
        filename, headers = opener.retrieve(url)
        print
        self.extract_file(filename, destdir)
        os.remove(filename)
    
    def extract(self, thing, destdir='.'):
        if isurl(thing):
            archivename = split(urllib.url2pathname(thing))[1]
        elif isfile(thing):
            archivename = split(thing)[1]
            
        print "+ Extracting..."
        print "    thing: %s" % thing
        print "    archive name: %s" % archivename
        print "    destination: %s" % destdir
        print "    type: %s" % self.desc
        
        if not exists(destdir):
            answer = prompt("* Destination doesn't exist. Create? [Y/n] ", choices=['y','n'], default='y')
            if answer == 'n':
                print "+ Aborting..."
                return
            print "+ Creating: %s" % destdir
            os.mkdir(destdir)

        tempdir = tempfile.mkdtemp('', 'arf-', destdir)
        print "+ Extracting archive to: %s" % tempdir

        print "-"*50
                            
        if isurl(thing):
            self.extract_url(thing, tempdir)
        elif isfile(thing):
            self.extract_file(thing, tempdir)
        else:
            print "+ I don't know what the crap this thing is:\n\t%s\n\n...what're you trying to pull here, huh?!?!" % thing
            return
        
        print "-"*50
        
        print "archivename: %s" % repr(archivename)
        only_dir = only_dir_in_path(tempdir)
        if only_dir:
            target = join(destdir, only_dir)
            print "+ Placing contained directory in '%s'..." % target
            os.rename(join(tempdir, only_dir), target)
            os.removedirs(tempdir)
        else:
            dest = join(destdir, self.dirname_from_archivename(archivename))
            count = 1
            while exists(dest):
                dest = join(destdir, self.dirname_from_archivename(archivename)) + "(%d)"%count
                count += 1
            print "+ Renaming '%s' to '%s'" % (tempdir, dest)
            os.rename(tempdir, dest)
        
        print "* Done. ARF!"
        print



class TarballExtractor(FileExtractor):
    exts = ['.tar.gz', '.tar.bz2', '.tar', '.tgz']
    streamable = True
    desc = "TAR file"

    # interface
        
    def extract_file(self, filename, destdir=None):
        cmd = self.getcommand(filename)
        cmd = '%s "%s" -C "%s"' % (cmd, filename, destdir)
        print "executing: %s" % cmd
        execute(cmd)

    # utilities
    
    def getcommand(self, filename):
        if self.isgzipped(filename):
            cmd = "tar -zxvf"
        elif self.isbzipped(filename):
            cmd = "tar -jxvf"
        else:
            cmd = "tar -xvf"
        
        return cmd        
                
    def isgzipped(self, url):
        url = url.lower()
        return url.endswith('.gz') or url.endswith('.tgz')
    
    def isbzipped(self, url):
        return url.lower().endswith('.bz2')

    
class ZipExtractor(FileExtractor):
    exts = ['.zip', '.pk3', '.jar']
    streamable = False
    desc = "ZIP file"

    # interface
    
    def extract_file(self, filename, destdir=None):
        execute('unzip -o "%s" -d "%s"' % (filename, destdir))
        
class RarExtractor(FileExtractor):
    exts = ['.rar', '.001']
    streamable = True
    desc = "RAR file"
    
    def extract_file(self, filename, destdir=None):
        execute('unrar x "%s" "%s"' % (filename, destdir))

extractors = [
                TarballExtractor(),
                ZipExtractor(),
                RarExtractor(),
             ]

def extract(filename, destdir):
    for extractor in extractors:
        if extractor.canHandle(filename):
            extractor.extract(filename, destdir)
            return
    
    print "+ I can't extract THAT! Why you gotta play me like this?!"

if __name__ == '__main__':
    madProps()

    if len(sys.argv) <= 1:
        howToUseMe()
    
    else:
        args = sys.argv[1:]
        numargs = len(args)

        filename = args[0]
        
        if numargs == 1:
            destdir = '.'
        elif numargs == 2:
            destdir = args[1]

        extract(filename, destdir)
            

