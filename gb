#!/usr/bin/env ruby
#
#   TODOS:
# ----------------------------------------------
#   * show "remote" before "local"
#   * use slop
#     * -r removes (remote-)branch
#   * create remote branch (based on current?)
#   * prompt for confirmation when doing dangerous things
#     (or things that could be mistakes -- eg: creating a branch)
#   * eat ugly git messages and make them colourized and pretty 



require 'epitools'

#################################################################################

def git_repo?
  path = Path.pwd
  loop do
    return true if (path/".git").dir?
    break unless path.dirs.pop
  end
  false
end

def ensure_git_repo
  unless git_repo?
    puts "Error: must be in a git repo."
    exit 1
  end
end

def get_branches
  ensure_git_repo
  
  branches = Branches.new
  
  `git branch -a`.lines.map(&:strip).each do |line|
    if line =~ %r{^\* (.+)$}
      line = $1
      branches.current = line
    end

    case line
    when /->/
      # ignore aliases
    when %r{^remotes/(.+)$}
      branches.remote << $1
    else 
      branches.local << line
    end
  end
  
  branches
end  

#################################################################################

class Branches

  attr_accessor :local, :remote, :current

  def initialize
    @local = []
    @remote = []
    @current = nil
  end
  
  def local?(branch); local.include? branch; end
  def remote?(branch); remote.include? branch; end
  def current?(branch); current == branch; end

  def print
  
    puts
    
    [ [:remote, :green], [:local, :yellow] ].each do |type, color|
      puts "<grey>== <light_white>#{type} branches: <grey>=============".colorize
      for branch in send(type)
        selected = (branch == current && type == :local)
        puts "   #{branch}".send(selected ? :bright_yellow : color)
      end
      puts
    end
    
  end
  
end

#################################################################################
## Main

args = ARGV

if args.empty?
  
  get_branches.print  
  
elsif args.first.in? ["--help", "-h"]
  
  puts %{usage: gb <branch name>

eg:
  gb existingbranch           => switch to existing branch         
  gb newbranch                => create a new branch
  gb origin/remotebranch      => create/checkout remote branch
  gb -d branch                => delete local branch
  gb -d origin/branch         => delete remote branch
}
  
elsif args.first.in? ["-d", "-D"]
  
  branches = get_branches

  args.shift
  branch = args.shift
  
  if branches.local? branch
    puts "<grey>* <light_red>Deleting <light_yellow>#{branch}".colorize
    system("git branch -D #{branch}")
  elsif branches.remote? branch
    if prompt("You wanna delete a remote branch???") == "y"
      system("git push origin :#{branch}")
    else
      puts "Whew."
    end
  else
    puts "Unknown branch."
  end
  
else
  
  branches = get_branches
  
  branch = args.first

  if branches.local? branch
    puts "<grey>* <light_white>Switching to <light_yellow>#{branch}".colorize
    system("git checkout #{branch}")
  elsif branches.remote? branch
    puts "<grey>* <light_white>Tracking <light_yellow>#{branch}".colorize
    system("git checkout -t #{branch}")
  else
    puts "* Creating new branch #{branch}"
    system("git branch #{branch}")
    system("git checkout #{branch}")
  end    
  
end