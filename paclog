#!/usr/bin/ruby
require 'epitools'
require 'date'

Colored.force!

class Event < Struct.new(:datestr, :date, :cmd, :name, :v1, :v2)

  # [2015-01-04 04:21] [PACMAN] installed lib32-libidn (1.29-1)
  # [2015-01-04 04:21] [PACMAN] upgraded lib32-curl (7.38.0-1 -> 7.39.0-1)
  # [2015-01-07 04:39] [ALPM] upgraded intel-tbb (4.3_20141023-1 -> 4.3_20141204-1)
  # [2015-01-07 04:39] [ALPM] upgraded iso-codes (3.54-1 -> 3.57-1)

  DATE_RE = /[\d:-]+/
  LINE_RE = /^\[(#{DATE_RE} #{DATE_RE})\](?: \[(?:PACMAN|ALPM)\])? (removed|installed|upgraded) (.+) \((.+)(?: -> (.+))?\)$/

  CMD_COLORS = {
    'removed' => :light_red,
    'installed' => :light_yellow,
    'upgraded' => :light_green,
    nil => :white,
  }
  
  def self.from_line(line)
    if line =~ LINE_RE
      new($1, parse_date($1), $2, $3, $4, $5)
    else
      nil
    end
  end    
  
  def cmd_color
    CMD_COLORS[cmd]
  end

  def to_s
    date, time = datestr.split
    "<grey>[<white>#{date} #{time}<grey>] <#{cmd_color}>#{cmd} <light_cyan>#{name} #{"<light_white>#{v2} " if v2}<white>(#{v1})".colorize
  end  

  def self.parse_date(date)
    DateTime.strptime(date, "%Y-%m-%d %H:%M")
  end
 
end

def all_events
  return to_enum(:all_events) unless block_given?

  logs = Path["/var/log/pacman.log*"].sort_by(&:mtime)

  logs.each do |log|
    open(log, 'r').reverse_each do |line|
      if e = Event.from_line(line.strip)
        yield e 
      end
    end
  end
end

if $0 == __FILE__
  query = /#{ARGV.join ".+"}/ if ARGV.any?

  lesspipe do |less|
    if query
      all_events.select { |e| e.name =~ query }.each do |e|
        e.name = e.name.gsub(query) { |m| m.light_yellow.on_blue }
        less.puts e
      end
    else
      all_events.each { |e| less.puts e }
    end
  end
end
