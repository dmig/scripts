#!/usr/bin/env ruby

###########################################################

LOGFILE  = File.expand_path("~/play.log")
CACHEDIR = File.expand_path("~/play")

PLAYERS  = [
  [ "baka-mplayer", proc { |url, title| ["baka-mplayer", "-title", title, url] } ],
  [          "mpv", proc { |url, title| ["mpv", "--media-title", title, url] } ],
  [       "parole", proc { |url, title| ["parole", "-i", xspf_file(title, url)] } ],
  [        "totem", proc { |url, title| ["totem", xspf.path] } ],
  [      "mplayer", proc { |url, title| ["mplayer", "-title", title, "-cache", "20000", "-cache-min", "0.0128", url] } ],
]

PLAYER_NAMES = PLAYERS.map(&:first)

def which(bin)
  ENV["PATH"].split(":").each do |dir|
    full_path = File.join(dir, bin)
    return full_path if File.exists? full_path
  end
  nil
end  

def best_player
  PLAYERS.each do |bin, command|
    return bin if which(bin)
  end
  nil
end

#
# Returns a proc that takes two args: "url" and "title"
#
def player_proc(bin)
  Hash[PLAYERS][bin]
end

def parse_options
  require 'slop' # lazy load

  Slop.parse(help: true, strict: true) do
    banner 'Usage: play [options] <video URL, or history number>'

    on 'l',  'list',      "List <n> previously viewed videos"
    on 'd',  'download',  "Download video <n>"
    on 'p=', 'player',    "Video player to use: #{PLAYER_NAMES.join(", ")}", default: best_player
  end
end

###########################################################

class LogEntry < Struct.new(:date, :time, :url, :title, :pos)
  def initialize(line, pos)
    timestamp, url, title = line.strip.split(" | ", 3)
    date, time            = timestamp.split

    super(date, time, url, title, pos)
  end

  def to_s
    url
  end
end

###########################################################

def notify(type, title, body, time: 5)
  require 'cgi'

  puts "#{title}"
  puts "  #{body}"

  time_in_ms = time * 1000

  cmd = ["notify-send"]
  cmd << "--expire-time=#{time_in_ms}"
  cmd << "--app-name=play"
  cmd << "--icon=#{type}"
  cmd += [title, body].map {|s| CGI.escapeHTML s }

  system *cmd
end

def run(*cmd)
  require 'open3'
  # stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])  
  out, err, status = Open3.capture3(*cmd)
  [out.strip, err.strip, status]
end

def play_click_sound
  if which("mplayer")
    run "mplayer", "-really-quiet", File.expand_path("~/scripts/sounds/click.mp3")
  end
end

def xspf_file(title, media_url)
  require 'tempfile'
  require 'cgi'

  xml = %{<?xml version="1.0" encoding="UTF-8"?>
<playlist version="1" xmlns="http://xspf.org/ns/0/">
 <trackList>
  <track>
   <title>#{CGI.escape_html title}</title>
   <location>#{CGI.escape_html  media_url}</location>
  </track>
 </trackList>
</playlist>}

  file = Tempfile.create ["play", ".xspf"]
  file.puts xml
  file.close
  file
end

###########################################################

def youtube_dl(url)
  out, err, status = run("youtube-dl", "-o", "%(title)s (%(upload_date)s)", "--no-playlist", "-g", "--get-filename", url)

  if not status.success? or out.empty?
    notify(:error, "youtube-dl error #{status.exitstatus}:", "#{err}\n( #{url} )")
    exit 1
  end

  media_url, title = out.lines.take(2).map(&:strip)

  [media_url, title]
end


###########################################################

def write_to_log(url, title)
  open(LOGFILE, "a") do |f|
    timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
    f.puts "#{timestamp} | #{url} | #{title}"
  end
end

def log_entries
  open(LOGFILE, "wb") {} unless File.exists?(LOGFILE) # touch the logfile
  log = open(LOGFILE)
  log.reverse_each.lazy.with_index.map {|logline, i| LogEntry.new(logline, i+1) }
end

def entries_for_nums(nums)
  require 'set'

  nums    = Set.new(nums)
  entries = []

  log_entries.each do |entry|
    if nums.include? entry.pos
      entries << entry
      nums.delete entry.pos

      break if nums.empty?
    end
  end

  entries
end

###########################################################

def show_result(result, regexp=nil)
  require 'epitools/colored'

end  

def search(query=nil, n=10)
  require 'epitools/colored'

  if query
    if query.is_a? Array
      if query.any?
        query = query.join(" ") 
      else
        query = nil
      end
    end
  end

  regexp = /#{query}/i if query

  ## Header
  
  puts "----------------------------------".grey
  if query
    puts " <15>Searching for: <14>#{query.inspect}".colorize
  else
    puts " #{n} most recent plays:".light_white
  end
  puts "----------------------------------".grey
  puts

  entries = log_entries
  entries = entries.select { |entry| entry.title =~ regexp } if query
  results = entries.take(n).to_a.reverse

  max_pos_width = results.map(&:pos).sort.last.to_s.size

  results.each do |result|
    pos = result.pos

    indent = " " * (result.date.size - result.time.size)

    title = result.title
    title = title.gsub(regexp) { |m| "<14>#{m}</14>" } if regexp

    print "#{pos.to_s.rjust(max_pos_width)}. ".bright_yellow
    indent += " " * (max_pos_width + 2)

    puts "<10>#{result.date} <12>| <11>#{title}".colorize
    puts "<2>#{indent}#{result.time} <4>| <9>#{result.url}".colorize
    puts
  end
end

###########################################################


def download(*urls)
  urls << log_entries.first if urls.empty?

  urls.each do |url|
    system "youtube-dl", "--no-mtime", "--xattrs", "-o", "%(title)s.%(ext)s", url.to_s
  end
end

def play(url, player=nil)
  if url.is_a? LogEntry
    notify(:info, "Loading:", url.title, time: 4)
  else
    notify(:info, "Processing:", url.to_s, time: 3)
  end

  play_click_sound

  media_url, title = youtube_dl(url.to_s)
  
  write_to_log(url, title) unless url.is_a? LogEntry # if we're playing something from the history, don't re-log it

  notify(:video, "Playing:", title, time: 4)

  cmd = player_proc(player).call(media_url, title)
  system(*cmd)
end

###########################################################


if $0 == __FILE__
  opts = parse_options
  args = ARGV

  if args.empty?
    search
    exit
  elsif args.all? { |arg| arg =~ /^\d+$/ } # all args are numbers?
    nums = args.map(&:to_i)
  elsif args.all? { |arg| arg =~ %r{^https?://}i } # all args are urls?
    urls = args
  else # must be a search query
    query = args
  end

  if opts.list?
    if nums
      search(nil, nums.first)
      exit
    end
  end

  urls = entries_for_nums(nums) if nums

  if query

    search(query)

  elsif urls

    urls.each do |url|
      if opts.download?
        download(url)
      else
        if opts[:player]
          play(url, opts[:player])
        else
          notify(:error, "Could not find a player!", "You must install one of the following: #{PLAYER_NAMES.join(", ")}")
          exit 1
        end
      end
    end

  end
end
