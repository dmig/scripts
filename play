#!/usr/bin/env ruby

###########################################################

LOGFILE  = File.expand_path("~/play.log")
CACHEDIR = File.expand_path("~/play")

PLAYERS  = [
  [          "mpv", proc { |url, title| ["mpv", "--force-media-title", title, url] } ],
  [ "baka-mplayer", proc { |url, title| ["baka-mplayer", "-title", title, url] } ],
  [       "parole", proc { |url, title| ["parole", "-i", xspf_file(title, url)] } ],
  [        "totem", proc { |url, title| ["totem", xspf_file(title, url).path] } ],
  [      "mplayer", proc { |url, title| ["mplayer", "-title", title, "-cache", "20000", "-cache-min", "0.0128", url] } ],
]

PLAYER_NAMES = PLAYERS.map(&:first)

def which(bin)
  ENV["PATH"].split(":").each do |dir|
    full_path = File.join(dir, bin)
    return full_path if File.exists? full_path
  end
  nil
end  

def best_player
  PLAYERS.each do |bin, command|
    return bin if which(bin)
  end
  nil
end

#
# Returns a proc that takes two args: "url" and "title"
#
def player_proc(bin)
  Hash[PLAYERS][bin]
end

def parse_options
  gem 'slop', "~> 3.6"
  require 'slop'

  Slop.parse(help: true, strict: true) do
    banner 'Usage: play [options] <video URL, or history number>'

    on 'l',  'list',      "List <n> previously viewed videos"
    on 'a',  'all',       "List all videos (piped to less)"
    on 'd',  'download',  "Download video <n>"
    on 'p=', 'player',    "Video player to use: #{PLAYER_NAMES.join(", ")}", default: best_player
  end
end

###########################################################

class LogEntry < Struct.new(:date, :time, :url, :title, :pos)
  def initialize(line, pos)
    timestamp, url, title = line.strip.split(" | ", 3)
    date, time            = timestamp.split

    super(date, time, url, title, pos)
  end

  def to_s
    url
  end
end

###########################################################

def notify(type, title, body, time: 5)
  require 'cgi'

  puts "#{title}"
  puts "  #{body}"

  time_in_ms = time * 1000

  cmd = ["notify-send"]
  cmd << "--expire-time=#{time_in_ms}"
  cmd << "--app-name=play"
  cmd << "--icon=#{type}"
  cmd += [title, body].map {|s| CGI.escapeHTML s }

  system *cmd
end

def run(*cmd)
  require 'open3'
  # stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])  
  out, err, status = Open3.capture3(*cmd)
  [out.strip, err.strip, status]
end

def play_click_sound
  file = File.expand_path("~/scripts/sounds/click.mp3")
  # %w[mpg123 mplayer mpv].any? { |player| run(player, file).last.success? }
  fork { run("mplayer", file) }
end

def xspf_file(title, media_url)
  require 'tempfile'
  require 'cgi'

  xml = %{<?xml version="1.0" encoding="UTF-8"?>
<playlist version="1" xmlns="http://xspf.org/ns/0/">
 <trackList>
  <track>
   <title>#{CGI.escape_html title}</title>
   <location>#{CGI.escape_html  media_url}</location>
  </track>
 </trackList>
</playlist>}

  file = Tempfile.create ["play", ".xspf"]
  file.puts xml
  file.close
  file
end

###########################################################

def write_to_log(url, title)
  open(LOGFILE, "a") do |f|
    timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
    f.puts "#{timestamp} | #{url} | #{title}"
  end
end

def log_entries
  open(LOGFILE, "wb") {} unless File.exists?(LOGFILE) # touch the logfile
  log = open(LOGFILE)
  log.reverse_each.lazy.with_index.map {|logline, i| LogEntry.new(logline, i+1) }
end

def entries_for_nums(nums)
  require 'set'

  nums    = Set.new(nums)
  entries = []

  log_entries.each do |entry|
    if nums.include? entry.pos
      entries << entry
      nums.delete entry.pos

      break if nums.empty?
    end
  end

  entries
end

###########################################################

def search(query=nil, n=10, reverse=true, paged=false)
  require 'epitools/colored'

  if query
    if query.is_a? Array
      if query.any?
        query = query.join(" ") 
      else
        query = nil
      end
    end
  end

  regexp = /#{query}/i if query

  if paged
    output = IO.popen("less -RXFi", "w")
  else
    output = $stdout
  end

  ## Header
  
  output.puts "----------------------------------".grey
  if query
    output.puts " <15>Searching for: <14>#{query.inspect}".colorize
  else
    output.puts " #{n == 0 ? "All" : n} most recent plays:".light_white
  end
  output.puts "----------------------------------".grey
  output.puts

  entries = log_entries
  entries = entries.select { |entry| entry.title =~ regexp } if query
  entries = entries.take(n) unless n == 0

  if reverse
    results = entries.to_a.reverse
    max_pos_width = results.map(&:pos).sort.last.to_s.size
  else
    results = entries
    max_pos_width = 4
  end

  results.each do |result|
    pos = result.pos

    indent = " " * (result.date.size - result.time.size)

    title = result.title
    title = title.gsub(regexp) { |m| "<14>#{m}</14>" } if regexp

    output.print "#{pos.to_s.rjust(max_pos_width)}. ".bright_yellow
    indent += " " * (max_pos_width + 2)

    output.puts "<10>#{result.date} <12>| <11>#{title}".colorize
    output.puts "<2>#{indent}#{result.time} <4>| <9>#{result.url}".colorize
    output.puts
  end

  output.close if paged
rescue Errno::EPIPE
end

###########################################################

def download(*urls)
  urls << log_entries.first if urls.empty?

  urls.each do |url|
    system "youtube-dl", "--no-mtime", "--xattrs", "-f", "best", "--no-playlist", "-o", "%(title)s.%(ext)s", url.to_s
  end
end

def youtube_dl(url)
  out, err, status = run("youtube-dl", "-f", "best", "-o", "%(title)s (%(upload_date)s)", "--no-playlist", "-g", "--get-filename", url)

  if not status.success? or out.empty?
    notify(:error, "youtube-dl error #{status.exitstatus}:", "#{err}\n( #{url} )")
    exit 1
  end

  media_url, title = out.lines.take(2).map(&:strip)

  [media_url, title]
end

def play(url, player=nil)
  if url.is_a? LogEntry
    notify(:info, "Loading:", url.title, time: 4)
  else
    notify(:info, "Processing:", url.to_s, time: 3)
  end

  play_click_sound

  media_url, title = youtube_dl(url.to_s)
  
  write_to_log(url, title) unless url.is_a? LogEntry # if we're playing something from the history, don't re-log it

  notify(:video, "Playing:", title, time: 4)

  cmd = player_proc(player).call(media_url, title)
  system(*cmd)
end

###########################################################


if $0 == __FILE__

  if ARGV.any? { |arg| arg[/^-\w/] }
    opts = parse_options
  else
    opts = {player: PLAYER_NAMES.first}
  end

  args = ARGV

  if opts[:all]
    search(nil, 0, false, true)
    exit
  end

  if args.empty?
    search
    exit
  elsif args.all? { |arg| arg =~ /^\d+$/ } # all args are numbers?
    nums = args.map(&:to_i)
  elsif args.all? { |arg| arg =~ %r{^https?://}i } # all args are urls?
    urls = args
  else # must be a search query
    query = args
  end

  if opts[:list]
    if nums
      search(nil, nums.first)
      exit
    end
  end

  urls = entries_for_nums(nums) if nums

  if query

    search(query)

  elsif urls

    urls.each do |url|
      if opts[:download]
        download(url)
      else
        if opts[:player]
          play(url, opts[:player])
        else
          notify(:error, "Could not find a player!", "You must install one of the following: #{PLAYER_NAMES.join(", ")}")
          exit 1
        end
      end
    end

  end
end
