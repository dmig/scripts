#!/usr/bin/env ruby

require 'epitools'

POOL_SIZE=12

# === Updating /home/epi/pacaur/libutvideo-git/ (git pull) ===

# Already up-to-date.

# === Updating /home/epi/pacaur/masterpdfeditor/ (git pull) ===

# remote: Counting objects: 4, done.
# remote: Compressing objects: 100% (4/4), done.
# remote: Total 4 (delta 2), reused 0 (delta 0)
# Unpacking objects: 100% (4/4), done.
# From https://aur.archlinux.org/masterpdfeditor
#    ae1a839..02fc034  master     -> origin/master
# Updating ae1a839..02fc034
# Fast-forward
#  .SRCINFO | 12 ++++++------
#  PKGBUILD |  6 +++---
#  2 files changed, 9 insertions(+), 9 deletions(-)




module Enumerable

  def parallel_map(num_workers=8, &block)
    require 'thread'

    queue = Queue.new
    each { |e| queue.push e }

    Enumerator.new do |y|
      workers = (0...num_workers).map do
        Thread.new do
          begin
            while e = queue.pop(true)
              y << block.call(e)
            end
          rescue ThreadError
          end
        end
      end

      workers.map(&:join)
    end
  end

end



repos = Path["*/.git"].map(&:parent)

# puts "* pulling #{repos.size} git repos"

results = repos.parallel_map do |repo|
  # puts "  |_ #{repo}"
  result = Path.cd(repo) do
    IO.popen("git pull", err: [:child, :out]) { |io| io.read }
    # result = IO.popen("git pull", err: [:child, :out]) { |io| io.read }
    # puts "#{result.size} bytes"
    # puts Dir.pwd
  end

  [repo, result]
end

results.each do |repo, result|
  unless result["Already up-to-date."]
    puts
    puts "<8>========== <11>#{repo} <8>===============".colorize
    puts
    puts result
    puts
  else
    print "."
  end
end