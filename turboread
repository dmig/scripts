#!/usr/bin/env ruby
#######################################################################################################
# --------------------------------------------------------------
# TurboReader Pro! (c) 2014 by Chris Gahan (chris@ill-logic.com)
# --------------------------------------------------------------
# Speed-read your favourite text files!
#
# (Based on principles outlined here: http://www.spritzinc.com)
#######################################################################################################

require 'io/console'

#######################################################################################################

class Words

  PUNCTUATION = /[\.\?,!:]/

  attr_accessor :longest_word

  def initialize(filename)
    @pos    = 0

    text    = File.read(filename)
    @words  = text.split.select { |w| w =~ /[a-z]+/i }
    @longest_word = @words.max_by(&:size).size

    # p @words.max_by(&:size) # show longest word
  end

  def next
    @pos += 1
    current
  end

  def prev
    @pos -= 1
    current
  end

  def first
    @pos = 0
    current
  end

  def current
    @pos = [[0,@pos].max, @words.size-1].min # clamp to range
    @words[@pos]
  end

  def current_punctuated?
    current =~ /#{PUNCTUATION}$/
  end

end


#######################################################################################################
# ANSI codes:
#   http://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes

class Display

  def initialize(filename)
    @wpm    = 400
    @words  = Words.new(filename)
    @width  = @words.longest_word
    @paused = true
    @help   = false
    @current_word = ""

    print_main_template

    rewind
  end

  #----------------------------------------------------------

  def set_wpm(wpm)
    @wpm = [[wpm, 100].max, 4000].min # ensure wpm is between 100 and 4000
    print_current_word
  end

  def increase_wpm(amount)
    set_wpm @wpm + amount
  end

  def decrease_wpm(amount)
    set_wpm @wpm - amount
  end

  def wpm_delay
    delay = 60.0/@wpm
    delay *= 2 if @words.current_punctuated?
    delay
  end

  #----------------------------------------------------------

  def display_word(word)
    @current_word = word
    print_current_word
  end

  def next_word
    display_word @words.next
  end

  def prev_word
    display_word @words.prev
  end

  def rewind
    display_word @words.first
  end

  #----------------------------------------------------------

  # TODO: Read the x,y positions from the status and
  #       word lines from the terminal, so we don't have
  #       to do all this gross relative positioning.

  def print_main_template
    puts "========================================"
    puts "  TurboReader PRO! Get ready to READ!"
    puts "==========(press ? for help)============"
    puts
    puts "-" * (@width+2)
    puts
    puts "-" * (@width+2)
    puts
  end

  def print_current_word
    status  = paused? ? "(PAUSED!)" : "(#{@wpm} wpm)"
    word    = (@current_word || "")
    padding = @width - word.size

    # Colorize the 2nd character
    if word.size >= 2
      word = word[0] +
             "\e[31;1m" + 
             word[1] +
             "\e[0m" +
             word[2..-1]
    end

    print "\e[3F" # move up 3 lines
    print "  #{word}#{" "*padding}  #{status}"
    print "\e[K"  # clear to end-of-line
    print "\e[3E" # move down 3 lines
  end

  def show_message(message)
    print "\e[0G\e[K\e[F\e[K\e[E" # clear the status area
    print message
    print "\e[0G"
  end

  def toggle_help!
    @help = !@help

    if @help
      show_message "\e[F Q/^C = Quit | SPACE = Pause | Left/Right = Skip word | HOME = Rewind\e[E" +
                   " Up/Down = Increase/decrease wpm by 50 | 1-9 = Set wpm to <n> * 100\e[0G"
    else
      show_message "\e[E"
    end
  end

  def paused?
    @paused
  end

  def pause!
    @paused = !@paused
    print_current_word
  end

  def quit!
    # quit
    show_message "Thank you for reading!\e[2S"
    exit
  end
end

#######################################################################################################
# A little DSL for defining keyboard commands

class KeyMap

  attr_accessor :config

  #-----------------------------------------------------------------

  class Config

    NAMED_KEYS = {
      :up     => "\e[A",
      :down   => "\e[B",
      :left   => "\e[C",
      :right  => "\e[D",
      :home   => "\eOH",
      :end    => "\eOF",
      :pgup   => "\e[5~",
      :pgdown => "\e[6~",
    }

    attr_accessor :trie_root

    def initialize(&block)
      @trie_root = {}

      instance_eval(&block)

      # Make sure ^C is defined
      @trie_root["\C-c"] ||= { handler: proc { exit } }
    end

    #
    # Add a command to the trie of input sequences
    #
    def key(*seqs, &block)
      seqs.each do |seq|
        if keycode = NAMED_KEYS[seq]
          seq = keycode
        end

        level = @trie_root

        seq.each_char do |c|
          level = (level[c] ||= {})
        end
        
        level[:handler] = block
      end
    end

    #
    # This block will be run if the key isn't defined.
    #
    def default(&block)
      if block_given?
        @default = block
      else
        @default
      end
    end
  end

  #-----------------------------------------------------------------

  def initialize(&block)
    @config = Config.new(&block)
  end

  def process(input)
    level = config.trie_root

    # Read one character at a time from the input, and incrementally
    # walk through levels of the trie until a :handler is found, or
    # we hit a dead-end in the trie.
    loop do
      c = input.getc

      if found = level[c]
        level = found

        if handler = level[:handler]
          handler.call(c)
          level = config.trie_root
        end
      else
        config.default.call(c) if config.default
        level = config.trie_root
      end
    end
  end

end

#######################################################################################################

if $0 == __FILE__
  if ARGV.empty?
    puts "Usage: turboread <filename.txt>"
    exit 1
  end

  filename = ARGV.first

  unless File.exists? filename
    puts "Error: #{filename.inspect} not found."
    exit 2
  end

  display = Display.new filename

  keymap = KeyMap.new do
    key(" ")      { display.pause! }
    key("?", "h") { display.toggle_help! }

    key(:up)      { display.increase_wpm(50) }
    key(:down)    { display.decrease_wpm(50) }

    key(:pgup)    { display.increase_wpm(200) }
    key(:pgdown)  { display.decrease_wpm(200) }

    key(:left)    { display.next_word }
    key(:right)   { display.prev_word }
    key(:home)    { display.rewind }

    key( *("1".."9").to_a ) { |c| display.set_wpm c.to_i*100 }
    key( "0" ) { display.set_wpm 1000 }

    key("q", "Q", "\C-c") { display.quit! }

    default { |c| display.show_message " Unknown command: #{c}" }
  end

  #------------------------------------------------------
  # thread1: handle keyboard events
  keyboard_thread = Thread.new do
    STDIN.raw do |input|
      keymap.process(input)
    end
  end

  #------------------------------------------------------
  # thread2: read the text
  reading_thread = Thread.new do
    loop do
      display.next_word unless display.paused?
      sleep display.wpm_delay
    end
    display.quit!
  end

  #------------------------------------------------------
  # Yield control of the program to the keyboard thread.
  keyboard_thread.join 
end
