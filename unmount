#!/usr/bin/env ruby
require 'epitools'

args = ARGV

unless args.any?
  puts "usage: unmount <directory> [ <directory> [ ... ] ]"
  exit 1
end

# /dev/sda2 on / type ext4 (rw,errors=remount-ro,commit=0)

class Mount < Struct.new(:dev, :path, :type, :options)
  
  def self.from_line(line)
    if line =~ %r{^(\S+) on (\S+) type (\S+) \((\S+)\)$} 
      new($1, $2, $3, $4)
    end
  end
  
end

fuser_types = {
 "c"=>"current directory",
 "e"=>"executable being run",
 "f"=>"open file",
 "F"=>"open file for writing",
 "r"=>"root directory",
 "m"=>"mmap'ed file or shared library"
}  

def processes(mointpoint)
  procs = Sys.ps
  # /maverick:            1865 10335c 14155c 14156c 14157c 14165c 14178c
  if `fuser -M -m #{mountpoint}` =~ /#{mointpoint}:\s+(.+)/
    pids, types = $1.scan(/(\d+)(.*)/).transpose
    Sys.ps.zip types
    
  end
end

mounts = `mount`.lines.map{|line| Mount.from_line(line) }.compact

for arg in args
  
  print "unmount #{arg.inspect}: "
  
  unless File.directory? arg
    puts "FAIL! (not a directory)"
    next
  end
  
  realpath = File.realpath(arg)

  match = mounts.select{|mount| realpath[/^#{Regexp.escape mount.path}/] }.sort_by{|m| m.path.size}.last
  
  unless match
    puts "FAIL! (not mounted)"
    next
  end
  
  success = if match.type[/^fuse/]
              system("fusermount -u #{match.path}")
            else
              system("sudoifnotroot umount #{match.path}")
            end
    
  puts( success ? "SUCCESS!" : "FAIL!" )
      
end
