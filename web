#!/usr/bin/env ruby

##############################################################

require 'epitools/sys'
require 'epitools/wm'
require 'epitools/path'
require 'epitools/rash'

##############################################################

BROWSERS = %w[
  opera
  chrome
  chromium
  midori
  firefox
  jumanji
]

VIDEO_SITES = %w[
  youtube.com
  youtu.be
  liveleak.com
  justin.tv
  vimeo.com
  infoq.com
]

BROWSER_OVERRIDES = {
  proc { host[/(#{VIDEO_SITES.map{|s| Regexp.escape(s)}.join("|")})/] } => %w[chrome chromium firefox],
}

##############################################################
## Check for required binaries (in the path)
missing = false
{"wmctrl"=>"wmctrl", "xse" => "xsendevent", "xclip" => "xclip"}.each do |bin, package|
  unless Path.which(bin)
    puts "* '#{bin}' not found in path; please install the '#{package}' package."
    missing = true
  end
end
exit 1 if missing

##############################################################

def select_parents(query, &block)
  process = Sys.ps($$).first.parent

  parents = []
  while process
    parents << process
    process = process.parent
  end

  block ||= proc { |process| process.command[query] }

  parents.select &block
end

def opened_by?(program)
  find_in_parents(program)
end

def browsers_for(url)
  uri = URI.parse(url)
  _, override = BROWSER_OVERRIDES.find { |tester, _| uri.instance_eval(&tester) }

  if override
    override | BROWSERS
  else
    BROWSERS
  end
end

def find_browsers(windows, browsers)
  browsers.map do |browser_name|
    browser_window = windows.select do |w|
      next if w.command.nil?
      bin = w.command.split.first
      bin[browser_name]
    end.first
    [ browser_name, browser_window ] if browser_window
  end.compact
end

def best_browser_for(url)

  browsers = browsers_for(url)

  # Group by browsers
  browsers_on_current_desktop = find_browsers(WM.current_desktop.windows, browsers)

  if browsers_on_current_desktop.any?
    browser_name, win = browsers_on_current_desktop.first
    # p [:activating_browser_on_current_desktop, win]
  elsif 
    browsers_on_all_desktops = find_browsers(WM.windows)
    if browsers_on_all_desktops.any?
      browser_name, win  = browsers_on_all_desktops.first
      # p [:activating_browser_on_other_desktop, win]
    end
  end

  [browser_name, win]
end

def to_clipboard(string)
  IO.popen("xclip -selection clipboard", "w") { |clip| clip << string }
end

def route(url)
  name, browser = best_browser_for(url)

  puts "* Opening #{url.inspect} in #{name} on #{browser.desktop.name}"

  to_clipboard(url)

  browser.send_keys("<Ctrl-T><Ctrl-L><Ctrl-V>")
  sleep 0.2
  browser.send_keys("<Ctrl-L><Return>")
  
  browser.activate!
end

##############################################################

if $0 == __FILE__
  if ARGV.any? { |arg| arg == "--help" }
    puts "== Usage: =="
    puts " web <url>"
    puts
    puts "== What it Does: =="
    puts " Opens the url in the best browser on the current desktop."
    puts " If there's no browser on the current desktop, it finds the"
    puts " best browser on the nearest desktop and jumps to that one."
    puts
    puts "== These are the browsers it will try to use (in order): =="
    puts " #{BROWSERS.join(", ")}"
    puts
    exit
  end

  if url = ARGV.first
    route url
  else
    puts "usage: browser-router <url>"
  end
end
