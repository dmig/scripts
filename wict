#!/usr/bin/env ruby

#require 'epitools'
require 'slop'
require "tokyocabinet"
include TokyoCabinet

# http://toolserver.org/~enwikt/definitions/?sortby=7
ENGLISH   = "http://toolserver.org/~enwikt/definitions/enwikt-defs-latest-en.tsv.gz"
ALL       = "http://toolserver.org/~enwikt/definitions/enwikt-defs-latest-all.tsv.gz"

CACHE_DIR = File.expand_path("~/.cache/wict")
INDEX     = File.join CACHE_DIR, "enwikt-defs.idx"


def options
  require 'slop' # lazy loaded
  @opts ||= Slop.parse(help: true, strict: true) do
    banner 'Usage: wict [options] <word...>'

    on 'u',  'update',  'Update the database'
    on 'a',  'all',     'All langauges!'
  end
end

def bdb_open(filename, opts=nil)
  bdb = BDB::new  # B-Tree database; keys may have multiple values

  if !bdb.open(filename, opts)
    raise "open error: #{bdb.errmsg(bdb.ecode)} (filename: #{filename.inspect})"
  end

  bdb
end

def backup(src)
  if File.exists? src
    counter = 1
    dest = "#{src}.bak"

    while File.exists? dest
      counter += 1
      dest = "#{src}.bak#{counter}"
    end

    puts "Backing up #{src.inspect} to #{dest.inspect}"

    File.rename(src, dest)
  end
end

def update
  backup(INDEX)

  url = options.all? ? ALL : ENGLISH

  IO.popen("curl -s #{url} | gunzip -c", "r") do |tsv|

    bdb = bdb_open(INDEX, BDB::OWRITER | BDB::OTRUNC | BDB::OCREAT)

    tsv.each.with_index do |line, n|
      lang, word, type, definition = line.strip.split("\t")
      #puts "<8>[<2>#{endpos}<8>] <11>#{word} <8>(<7>#{type}<8>)<2>: <9>#{definition}".colorize

      bdb.putdup(word, definition)

      print "\b"*20 + n.to_s if n % 37 == 0
    end

    puts

    bdb.close
  end

end  


Dir.mkdir CACHE_DIR unless File.exists? CACHE_DIR

if options.update?

  puts "Updating database..."
  update
  puts

else

  if not File.exists? INDEX
    puts "You must first download a database. Run 'wict -u'."
    exit 1
  end

  bdb = bdb_open(INDEX)

  ARGV.each do |arg| 
    words = bdb.fwmkeys(arg)
    words.each do |word|
      defs = bdb.getlist(word)
      if defs.any?
        puts "#{word}"
        defs.each { |defn| puts "   #{defn}" }
        puts
      end
    end
  end

end  
